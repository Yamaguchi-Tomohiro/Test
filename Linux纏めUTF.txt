P118~141

Linuxのしくみ　著：武内覚
勉強会用、纏め資料

# 仮想記憶の応用

* ファイルマップ

* デマンドページング

* コピーオンライト方式の高速なプロセス生成

* 未解決疑問点
 プロセスは自分自身の実行中にページフォールトが発生したことに気づけないとはどういうことか。
カーネル内の仕組みであるページフォルトハンドラが働くことで解決？される。仮想アドレス空間を管理しているカーネルのような、プロセスより上位のレイヤーからしか見ることはできないということか・・・？

 一旦、～し、実際に必要な際に～する。←この考え方はよく出る（共通のものなのか？ITに限らない気もするが・・・？）

例：ユーザがファイルへの書き込みを行う場合
ファイルを開いた後、write()等のシステムコールを用いて、処理結果をカーネルが管理するファイルに反映する必要がある

## ファイルマップ
プロセスがファイル等にアクセスする際には、ファイルを開いた後、「read()」「write()」「lseek()」等のシステムコールを使用する。
Linuxでは、ファイルの領域を仮想アドレス空間上にメモリマップする機能がある。

1.図05-28にあるように、ストレージデバイスにあるファイルの内容をメモリ上にコピーする
2.物理メモリ上のアドレスと仮想アドレス空間上のアドレスはマッピングされており、仮想アドレス空間上のアドレスに対して行われた処理はカーネルを介して、物理メモリ上で行われる。
  これによってプロセスは、物理メモリ上のアドレスを意識せずにファイルに対する処理を行うことができる。
3.物理メモリ上のファイルに対して行われた処理結果は、所定のタイミングでストレージデバイス上のファイルに書き戻される。（６章参照）

後のタイミングでストレージデバイス上のファイルに書き戻される（処理結果が反映される？）という処理はGitのコミット結果をPushするという考え方に似ていると感じました。

## デマンドページング
プロセス生成時、mmap()システムコールによってプロセスにメモリを割り当てる際には、上記の1,2の手順を踏む。
しかしこの方法では、下記のように物理メモリを獲得してから終了するまでの間に、使用されない領域が存在する。

* プログラムの実行中に使用されなかった機能の為に、確保されたコード領域や、データ領域

* glibcが確保したメモリプールの内、ユーザがmalloc()関数で確保しなかった領域

これらの無駄を解消する機能が「デマンドページング」である。

最初は図３０のように「プロセスに割り当て済みだが、物理メモリは割り当てていない状態」である

1.プログラムがエントリポイントにアクセス
2.CPUがページテーブルを参照し、エントリポイントに属するページと対応した仮想アドレスが物理アドレスと紐づいていないことを検知
3.CPUでページフォールトが発生
4.カーネルのページフォールトハンドラが、1でアクセスしたページに物理メモリを割り当て、ページテーブルを書き換える
5.ユーザモードに戻ってプロセスが実行される
（3,4はカーネルモードでの動作）

プロセスがmmap()関数等で動的にメモリを獲得した場合でも、先ずは仮想アドレスを用意し、実際に処理が行われる際に、物理アドレスとの紐づきがない事を検知→物理アドレスを獲得し、処理を行うという流れになる。

仮想アドレスは用意するが、物理メモリは確保したという建前で、実際には割り当てていない状態を作る。
実際に処理が行われ、物理メモリが必要になった時点で、物理メモリとのマッピングを行い、処理が行われる。

デマンドページングによる割り当てでは、mmap()関数でメモリ確保に成功したとしても、その後のメモリへの書き込み処理が行われる時点で物理メモリに十分な空き領域が泣ければ、物理メモリの枯渇が発生する。


## 仮想メモリの枯渇と、物理メモリの枯渇

仮想メモリの枯渇：プロセスが仮想アドレス空間の範囲一杯まで仮想メモリを使い切った状態で、メモリを獲得しようとした際に起こる・図３５
x86アーキテクチャでは、仮想アドレス空間が４Gバイトしかなかった為、大型プログラムを実行する際に頻発していた。
x86_64アーキテクチャでは、仮想アドレス空間が128Tバイトあるので、発生は稀となった

物理メモリの枯渇：システムに搭載されている物理メモリを使い切った状態

## コピーオンライト
プロセス生成の際に使用するfork()システムコールも仮想記憶の仕組みを利用し、高速化されている
fork()が使用された際には、親プロセスのメモリを子プロセスにすべてコピーするのではなく、ページテーブルの実をコピーする
ページテーブルでは、書き込み権限を示すフィールドが存在するが、この時には、親も子も全ページの書き込み権限を無効かする
読み込みの処理だけであれば、どちらのプロセスも共有された物理ページにアクセス可能
親プロセスか子プロセスのいずれかが、ページのどこかを更新しようとすると、共有を解除する。
1.ページへの書き込みは許可されていないので、書き込み時にCPU上でページフォルトが発生
2.CPUがカーネルモードに移行し、カーネルのページフォールトハンドラが動く
3.ページフォールトハンドラは、アクセスされたページを別の場所にコピーし、書き込もうとしたプロセスに割り当て、内容を書き換える
4.それぞれのプロセスに対し、共有が解除されたページに対応するページエントリの書き込み権限を更新する
それぞれのプロセスが利用する物理メモリ使用量のうち、親プロセスと子プロセスで共有されているメモリは、それぞれのプロセスで二重計上される


仮想メモリシステムでは、それらに使用されるアドレスはすべて仮想アドレスで あり、物理アドレスではない。それらの仮想アドレスはプロセッサによって物理 アドレスに変換されるのだが、その変換は、オペレーティングシステムが管理する 変換テーブルに保持された情報を基にして行われる。
この変換を容易にするため、仮想メモリと物理メモリは、ページ(page)と呼ばれる 扱い易い単位に分割されている。それらのページはすべて同じサイズである。ページ のサイズは必ずしも同一である必要はないのだが、同一サイズでない場合、システム による管理が非常に困難なものになるためにそうされている。Alpha AXP システム上 の Linux では、8 k バイトのページを使用し、Intel x86 システムでは、4 k バイト のページが使用されている。ページそれぞれには、他と重複しない数値のページ フレーム番号(Page Frame Number, PFN)が割り振られている。
このようにページ分割されたシステムの場合、仮想アドレスは、オフセット(offset) と仮想ページフレーム番号(PFN)のふたつの部分から構成される。ページサイズが 4 k バイトならば、仮想アドレスの bit 11 から 0 にオフセットが含まれていて、 bit 12 以降が仮想ページフレーム番号となっている。 プロセッサは仮想アドレスに出会うたびに、オフセット番号と仮想ページフレーム 番号を抽出する。プロセッサは、仮想ページフレーム番号を物理ページフレーム番号 に変換し、その上で、該当する物理ページの正しいオフセット番号の位置にアクセス する。その変換のために、プロセッサはページテーブル(page table)を使用する
http://archive.linux.or.jp/JF/JFdocs/The-Linux-Kernel-4.html

発表が終了したため、編集終了

